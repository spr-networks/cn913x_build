From 5b5755b32b4f8eaf51c72a12269b27b24b10b011 Mon Sep 17 00:00:00 2001
From: Alvaro Karsz <alvaro.karsz@solid-run.com>
Date: Mon, 31 Oct 2022 12:40:38 +0200
Subject: [PATCH] DPDK support for MVPP2.

Allow DPDK to take control over the network interfaces.

When a DPDK application starts, DPDK takes control.
When a DPDK application stops, the control should be returned to the Linux kernel,
however, at the moment, this part is not working.

Signed-off-by: Alvaro Karsz <alvaro.karsz@solid-run.com>
---
 arch/arm64/boot/dts/marvell/armada-ap80x.dtsi |   5 +
 arch/arm64/boot/dts/marvell/armada-cp11x.dtsi |   7 +
 drivers/net/ethernet/marvell/mvpp2/mvpp2.h    |   4 +
 .../net/ethernet/marvell/mvpp2/mvpp2_main.c   | 237 +++++++++++++++---
 4 files changed, 216 insertions(+), 37 deletions(-)

diff --git a/arch/arm64/boot/dts/marvell/armada-ap80x.dtsi b/arch/arm64/boot/dts/marvell/armada-ap80x.dtsi
index 661447210..5d4994db7 100644
--- a/arch/arm64/boot/dts/marvell/armada-ap80x.dtsi
+++ b/arch/arm64/boot/dts/marvell/armada-ap80x.dtsi
@@ -301,6 +301,11 @@ ap_thermal: thermal-sensor@80 {
 					#thermal-sensor-cells = <1>;
 				};
 			};
+
+			musdk_cma {
+				compatible = "marvell,musdk-cma";
+				dma-coherent;
+			};
 		};
 	};

diff --git a/arch/arm64/boot/dts/marvell/armada-cp11x.dtsi b/arch/arm64/boot/dts/marvell/armada-cp11x.dtsi
index 84afbd9db..11be3043b 100644
--- a/arch/arm64/boot/dts/marvell/armada-cp11x.dtsi
+++ b/arch/arm64/boot/dts/marvell/armada-cp11x.dtsi
@@ -126,6 +126,13 @@ CP11X_LABEL(eth2): eth2 {
 				status = "disabled";
 			};
 		};
+                CP11X_LABEL(uio_ethernet): EVALUATOR(uio_pp_, CP11X_NUM)@0 {
+                          compatible = "marvell,mv-pp-uio";
+                          reg = <0x0 0x90000>, <0x130000 0x6000>,
+                                <0x220000 0x1000>;
+                          reg-names = "pp", "mspg", "cm3";
+                };
+

 		CP11X_LABEL(comphy): phy@120000 {
 			compatible = "marvell,comphy-cp110";
diff --git a/drivers/net/ethernet/marvell/mvpp2/mvpp2.h b/drivers/net/ethernet/marvell/mvpp2/mvpp2.h
index cf8acabb9..58c8dcd3f 100644
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2.h
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2.h
@@ -865,6 +865,7 @@
 /* Port flags */
 #define MVPP2_F_LOOPBACK		BIT(0)
 #define MVPP2_F_DT_COMPAT		BIT(1)
+#define MVPP22_F_IF_MUSDK		BIT(2)

 /* Marvell tag types */
 enum mvpp2_tag_type {
@@ -1268,6 +1269,9 @@ struct mvpp2_port {
 	enum hwtstamp_tx_types tx_hwtstamp_type;
 	struct mvpp2_hwtstamp_queue tx_hwtstamp_queue[2];

+	/* us private storage, allocated/used by User/Kernel mode toggling */
+	void *us_cfg;
+
 	/* Firmware TX flow control */
 	bool tx_fc;
 };
diff --git a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
index d5c92e43f..8bf808bcf 100644
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
@@ -1431,9 +1431,6 @@
        if (cpu >= port->priv->nthreads)
                return;

-       if (port->flags & MVPP22_F_IF_MUSDK)
-               return;
-
        thread = mvpp2_cpu_to_thread(port->priv, cpu);

        val = MVPP2_CAUSE_MISC_SUM_MASK |
@@ -1857,13 +1854,6 @@
        return val;
 }

-static const char mvpp22_priv_flags_strings[][ETH_GSTRING_LEN] = {
-       "musdk",
-};
-
-#define MVPP22_F_IF_MUSDK_PRIV BIT(0)
-
-
 /* Some counters are accessed indirectly by first writing an index to
  * MVPP2_CTRS_IDX. The index can represent various resources depending on the
  * register we access, it can be a hit counter for some classification tables,
@@ -1960,48 +1950,42 @@
        struct mvpp2_port *port = netdev_priv(netdev);
        int i, q;

-       switch (sset) {
-       case ETH_SS_STATS:
-               for (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_mib_regs); i++) {
-                       strscpy(data, mvpp2_ethtool_mib_regs[i].string,
-                               ETH_GSTRING_LEN);
-                       data += ETH_GSTRING_LEN;
-               }
+       if (sset != ETH_SS_STATS)
+               return;

-               for (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_port_regs); i++) {
-                       strscpy(data, mvpp2_ethtool_port_regs[i].string,
-                               ETH_GSTRING_LEN);
+       for (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_mib_regs); i++) {
+               strscpy(data, mvpp2_ethtool_mib_regs[i].string,
+                       ETH_GSTRING_LEN);
+               data += ETH_GSTRING_LEN;
+       }
+
+       for (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_port_regs); i++) {
+               strscpy(data, mvpp2_ethtool_port_regs[i].string,
+                       ETH_GSTRING_LEN);
+               data += ETH_GSTRING_LEN;
+       }
+
+       for (q = 0; q < port->ntxqs; q++) {
+               for (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_txq_regs); i++) {
+                       snprintf(data, ETH_GSTRING_LEN,
+                                mvpp2_ethtool_txq_regs[i].string, q);
                        data += ETH_GSTRING_LEN;
                }
+       }

-               for (q = 0; q < port->ntxqs; q++) {
-                       for (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_txq_regs); i++) {
-                               snprintf(data, ETH_GSTRING_LEN,
-                                       mvpp2_ethtool_txq_regs[i].string, q);
-                               data += ETH_GSTRING_LEN;
-                       }
-               }
-
-               for (q = 0; q < port->nrxqs; q++) {
-                       for (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_rxq_regs); i++) {
-                               snprintf(data, ETH_GSTRING_LEN,
-                                       mvpp2_ethtool_rxq_regs[i].string,
-                                       q);
-                               data += ETH_GSTRING_LEN;
-                       }
-               }
-
-               for (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_xdp); i++) {
-                       strscpy(data, mvpp2_ethtool_xdp[i].string,
-                               ETH_GSTRING_LEN);
+       for (q = 0; q < port->nrxqs; q++) {
+               for (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_rxq_regs); i++) {
+                       snprintf(data, ETH_GSTRING_LEN,
+                                mvpp2_ethtool_rxq_regs[i].string,
+                                q);
                        data += ETH_GSTRING_LEN;
                }
-               break;
+       }

-       case ETH_SS_PRIV_FLAGS:
-               memcpy(data, mvpp22_priv_flags_strings,
-                      ARRAY_SIZE(mvpp22_priv_flags_strings) * ETH_GSTRING_LEN);
-               break;
+       for (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_xdp); i++) {
+               strscpy(data, mvpp2_ethtool_xdp[i].string,
+                       ETH_GSTRING_LEN);
+               data += ETH_GSTRING_LEN;
        }
 }

@@ -2150,9 +2134,6 @@

        if (sset == ETH_SS_STATS)
                return MVPP2_N_ETHTOOL_STATS(port->ntxqs, port->nrxqs);
-               else if (sset == ETH_SS_PRIV_FLAGS)
-                       return (port->priv->hw_version == MVPP21) ?
-                               0 : ARRAY_SIZE(mvpp22_priv_flags_strings);

        return -EOPNOTSUPP;
 }
@@ -2230,9 +2211,6 @@
 {
        u32 val;

-       if (port->flags & MVPP22_F_IF_MUSDK)
-                       return;
-
        val = readl(port->base + MVPP2_GMAC_CTRL_0_REG);
        val &= ~MVPP2_GMAC_MAX_RX_SIZE_MASK;
        val |= (((port->pkt_size - MVPP2_MH_SIZE) / 2) <<
@@ -2245,9 +2223,6 @@
 {
        u32 val;

-       if (port->flags & MVPP22_F_IF_MUSDK)
-                       return;
-
        val =  readl(port->base + MVPP22_XLG_CTRL1_REG);
        val &= ~MVPP22_XLG_CTRL1_FRAMESIZELIMIT_MASK;
        val |= ((port->pkt_size - MVPP2_MH_SIZE) / 2) <<
@@ -2350,9 +2325,6 @@
        int queue;
        int tx_port_num = mvpp2_egress_port(port);

-       if (port->flags & MVPP22_F_IF_MUSDK)
-                       return;
-
        /* Enable all initialized TXs. */
        qmap = 0;
        for (queue = 0; queue < port->ntxqs; queue++) {
@@ -2375,9 +2347,6 @@
        int delay;
        int tx_port_num = mvpp2_egress_port(port);

-       if (port->flags & MVPP22_F_IF_MUSDK)
-                       return;
-
        /* Issue stop command for active channels only */
        mvpp2_write(port->priv, MVPP2_TXP_SCHED_PORT_INDEX_REG, tx_port_num);
        reg_data = (mvpp2_read(port->priv, MVPP2_TXP_SCHED_Q_CMD_REG)) &
@@ -3446,11 +3415,9 @@
                mvpp2_egress_enable(port);
                mvpp2_ingress_enable(port);
                netif_carrier_on(dev);
-               if (!(port->flags & MVPP22_F_IF_MUSDK))
-                       netif_tx_wake_all_queues(dev);
+               netif_tx_wake_all_queues(dev);
        } else {
-               if (!(port->flags & MVPP22_F_IF_MUSDK))
-                       netif_tx_stop_all_queues(dev);
+               netif_tx_stop_all_queues(dev);
                netif_carrier_off(dev);
                mvpp2_ingress_disable(port);
                mvpp2_egress_disable(port);
@@ -4625,8 +4592,7 @@
                mvpp2_acpi_start(port);
        }

-       if (!(port->flags & MVPP22_F_IF_MUSDK))
-               netif_tx_start_all_queues(port->dev);
+       netif_tx_start_all_queues(port->dev);

        clear_bit(0, &port->state);
 }
@@ -4772,7 +4738,7 @@
 static bool mvpp22_rss_is_supported(struct mvpp2_port *port)
 {
        return (queue_mode == MVPP2_QDIST_MULTI_MODE) &&
-               !(port->flags & MVPP2_F_LOOPBACK) && !(port->flags & MVPP22_F_IF_MUSDK);
+               !(port->flags & MVPP2_F_LOOPBACK);
 }

 static int mvpp2_open(struct net_device *dev)
@@ -4794,11 +4760,6 @@
                netdev_err(dev, "mvpp2_prs_mac_da_accept own addr failed\n");
                return err;
        }
-
-       if (port->flags & MVPP22_F_IF_MUSDK)
-                       goto skip_musdk_parser;
-
-
        err = mvpp2_prs_tag_mode_set(port->priv, port->id, MVPP2_TAG_TYPE_MH);
        if (err) {
                netdev_err(dev, "mvpp2_prs_tag_mode_set failed\n");
@@ -4810,8 +4771,6 @@
                return err;
        }

-skip_musdk_parser:
-
        /* Allocate the Rx/Tx queues */
        err = mvpp2_setup_rxqs(port);
        if (err) {
@@ -5055,11 +5014,6 @@
        struct mvpp2 *priv = port->priv;
        int err;

-       if (port->flags & MVPP22_F_IF_MUSDK) {
-                       netdev_err(dev, "MTU cannot be modified in MUSDK mode\n");
-                       return -EPERM;
-       }
-
        if (!IS_ALIGNED(MVPP2_RX_PKT_SIZE(mtu), 8)) {
                netdev_info(dev, "illegal MTU value %d, round to %d\n", mtu,
                            ALIGN(MVPP2_RX_PKT_SIZE(mtu), 8));
@@ -5118,92 +5072,6 @@
        return err;
 }

-static int mvpp2_port_musdk_cfg(struct net_device *dev, bool ena)
-{
-       struct mvpp2_port_us_cfg {
-               unsigned int nqvecs;
-               unsigned int nrxqs;
-               unsigned int ntxqs;
-               int mtu;
-               bool rxhash_en;
-               u8 rss_en;
-       } *us;
-
-       struct mvpp2_port *port = netdev_priv(dev);
-
-       if (ena) {
-               /* Disable Queues and IntVec allocations for MUSDK,
-                * but save original values.
-                */
-               us = kzalloc(sizeof(*us), GFP_KERNEL);
-               if (!us)
-                       return -ENOMEM;
-               port->us_cfg = (void *)us;
-               us->nqvecs = port->nqvecs;
-               us->nrxqs  = port->nrxqs;
-               us->ntxqs = port->ntxqs;
-               us->mtu = dev->mtu;
-               us->rxhash_en = !!(dev->hw_features & NETIF_F_RXHASH);
-               port->nqvecs = 0;
-               port->nrxqs  = 0;
-               port->ntxqs  = 0;
-               if (us->rxhash_en) {
-                       dev->hw_features &= ~NETIF_F_RXHASH;
-                       netdev_update_features(dev);
-               }
-       } else {
-               /* Back to Kernel mode */
-               us = port->us_cfg;
-               port->nqvecs = us->nqvecs;
-               port->nrxqs  = us->nrxqs;
-               port->ntxqs  = us->ntxqs;
-               if (us->rxhash_en) {
-                       dev->hw_features |= NETIF_F_RXHASH;
-                       netdev_update_features(dev);
-               }
-               kfree(us);
-               port->us_cfg = NULL;
-       }
-       return 0;
-}
-
-static int mvpp2_port_musdk_set(struct net_device *dev, bool ena)
-{
-       struct mvpp2_port *port = netdev_priv(dev);
-       bool running = netif_running(dev);
-       int err;
-
-       /* This procedure is called by ethtool change or by Module-remove.
-        * For "remove" do anything only if we are in musdk-mode
-        * and toggling back to Kernel-mode is really required.
-        */
-       if (!ena && !port->us_cfg)
-               return 0;
-
-       if (running)
-               mvpp2_stop(dev);
-
-       if (ena) {
-               err = mvpp2_port_musdk_cfg(dev, ena);
-               port->flags |= MVPP22_F_IF_MUSDK;
-       } else {
-               err = mvpp2_port_musdk_cfg(dev, ena);
-               port->flags &= ~MVPP22_F_IF_MUSDK;
-       }
-
-       if (err) {
-               netdev_err(dev, "musdk set=%d: error=%d\n", ena, err);
-               if (err)
-                       return err;
-               /* print Error message but continue */
-       }
-
-       if (running)
-               mvpp2_open(dev);
-
-       return 0;
-}
-
 static int mvpp2_check_pagepool_dma(struct mvpp2_port *port)
 {
        enum dma_data_direction dma_dir = DMA_FROM_DEVICE;
@@ -5551,9 +5419,6 @@
        c->rx_max_coalesced_frames = port->rxqs[0]->pkts_coal;
        c->tx_max_coalesced_frames = port->txqs[0]->done_pkts_coal;
        c->tx_coalesce_usecs       = port->tx_time_coal;
-       drvinfo->n_priv_flags = (port->priv->hw_version == MVPP21) ?
-               0 : ARRAY_SIZE(mvpp22_priv_flags_strings);
-
        return 0;
 }

@@ -5843,31 +5708,6 @@

        return mvpp22_port_rss_ctx_indir_set(port, *rss_context, indir);
 }
-
-static u32 mvpp22_get_priv_flags(struct net_device *dev)
-{
-       struct mvpp2_port *port = netdev_priv(dev);
-       u32 priv_flags = 0;
-
-       if (port->flags & MVPP22_F_IF_MUSDK)
-               priv_flags |= MVPP22_F_IF_MUSDK_PRIV;
-       return priv_flags;
-}
-
-static int mvpp22_set_priv_flags(struct net_device *dev, u32 priv_flags)
-{
-       struct mvpp2_port *port = netdev_priv(dev);
-       bool f_old, f_new;
-       int err = 0;
-
-       f_old = port->flags & MVPP22_F_IF_MUSDK;
-       f_new = priv_flags & MVPP22_F_IF_MUSDK_PRIV;
-       if (f_old != f_new)
-               err = mvpp2_port_musdk_set(dev, f_new);
-
-       return err;
-}
-
 /* Device ops */

 static const struct net_device_ops mvpp2_netdev_ops = {
@@ -5911,8 +5751,6 @@
        .set_rxfh               = mvpp2_ethtool_set_rxfh,
        .get_rxfh_context       = mvpp2_ethtool_get_rxfh_context,
        .set_rxfh_context       = mvpp2_ethtool_set_rxfh_context,
-       .get_priv_flags         = mvpp22_get_priv_flags,
-       .set_priv_flags         = mvpp22_set_priv_flags,
 };

 /* Used for PPv2.1, or PPv2.2 with the old Device Tree binding that
@@ -6736,8 +6574,7 @@

        mvpp2_egress_enable(port);
        mvpp2_ingress_enable(port);
-       if (!(port->flags & MVPP22_F_IF_MUSDK))
-               netif_tx_wake_all_queues(port->dev);
+       netif_tx_wake_all_queues(port->dev);
 }

 static void mvpp2_mac_link_down(struct phylink_config *config,
@@ -6760,8 +6597,7 @@
                }
        }

-       if (!(port->flags & MVPP22_F_IF_MUSDK))
-               netif_tx_stop_all_queues(port->dev);
+       netif_tx_stop_all_queues(port->dev);
        mvpp2_egress_disable(port);
        mvpp2_ingress_disable(port);

@@ -7165,7 +7001,6 @@
 {
        int i;

-mvpp2_port_musdk_set(port->dev, false);
        unregister_netdev(port->dev);
        if (port->phylink)
                phylink_destroy(port->phylink);
